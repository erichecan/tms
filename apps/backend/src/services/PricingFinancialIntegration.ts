// 计费引擎与财务系统集成服务
// 创建时间: 2025-09-29 03:15:00
// 作用: 根据PRD要求，在运单完成时自动生成财务记录

import { DatabaseService } from './DatabaseService';
import { PricingEngineService } from './PricingEngineService';
import { logger } from '../utils/logger';

export class PricingFinancialIntegration {
  private db: DatabaseService;
  private pricingService: PricingEngineService;

  constructor(dbService: DatabaseService, pricingService: PricingEngineService) {
    this.db = dbService;
    this.pricingService = pricingService;
    logger.info('PricingFinancialIntegration 初始化完成');
  }

  /**
   * 运单完成时触发财务记录自动生成
   * @param shipmentId 运单ID
   * @param finalCost 最终费用
   */
  async generateFinancialRecordsOnCompletion(shipmentId: string, finalCost: number, tenantId?: string): Promise<void> {
    const client = await this.db.getConnection();
    
    try {
      await client.query('BEGIN');

      // 1. 获取运单信息
      const shipmentResult = await client.query(
        'SELECT * FROM shipments WHERE id = $1 FOR UPDATE',
        [shipmentId]
      );

      if (shipmentResult.rowCount === 0) {
        throw new Error(`运单 ${shipmentId} 不存在`);
      }

      const shipment = shipmentResult.rows[0];

      // 2025-11-30T14:00:00Z Added by Assistant: 租户验证 - 确保运单属于正确的租户
      if (tenantId && shipment.tenant_id !== tenantId) {
        throw new Error(`运单 ${shipmentId} 不属于租户 ${tenantId}`);
      }

      if (!['delivered', 'pod_pending_review', 'completed'].includes(shipment.status)) {
        throw new Error(`运单 ${shipmentId} 状态不正确，无法生成财务记录`);
      }

      // 2. 重新计算计费明细（如果有计费模板）
      let pricingCalculation = null;
      if (shipment.pricing_template_id) {
        try {
          // 构建运单上下文并重新计算
          const shipmentContext = this.buildShipmentContext(shipment);
          pricingCalculation = await this.pricingService.calculatePricing(
            shipmentContext, 
            shipment.pricing_template_id
          );
          
          // 更新运单的预估费用字段
          await client.query(
            'UPDATE shipments SET estimated_cost_calculated = $1, pricing_components = $2, pricing_rule_trace = $3 WHERE id = $4',
            [
              pricingCalculation.totalRevenue,
              JSON.stringify(
                (pricingCalculation.revenueBreakdown || []).map(item => ({ 
                  code: item.componentCode, 
                  label: item.componentName, 
                  calcType: 'rule_engine',
                  amount: item.amount, 
                  sourceRuleId: item.ruleId 
                }))
              ),
              JSON.stringify(
                (pricingCalculation.appliedRules || []).map(ruleId => ({ 
                  ruleId, 
                  version: pricingCalculation.pricingVersion, 
                  appliedAt: pricingCalculation.calculatedAt 
                }))
              ),
              shipmentId
            ]
          );
          
          logger.info(`运单 ${shipmentId} 重新计算了计费结果`, {
            totalRevenue: pricingCalculation.totalRevenue,
            totalDriverPay: pricingCalculation.totalDriverPay
          });

        } catch (error) {
          logger.warn(`运单 ${shipmentId} 计费重新计算失败，使用手动输入的finalCost`, error);
        }
      }

      // 3. 生成应收记录（客户应该支付的钱）
      await this.generateReceivableRecord(client, shipment, finalCost, pricingCalculation);

      // 4. 生成应付记录（司机应该得到的钱）
      await this.generatePayableRecord(client, shipment, finalCost, pricingCalculation);

      if (shipment.status !== 'completed') {
        await client.query(
          'UPDATE shipments SET status = $1, final_cost = $2, updated_at = NOW() WHERE id = $3',
          ['completed', finalCost, shipmentId]
        );
        await client.query(`
          INSERT INTO timeline_events (shipment_id, event_type, from_status, to_status, actor_type, timestamp, extra)
          VALUES ($1, 'COMPLETED', $2, 'completed', 'system', NOW(), $3)
        `, [shipmentId, shipment.status, JSON.stringify({ finalCost, autoGenerated: true })]);
      } else {
        await client.query(
          'UPDATE shipments SET final_cost = $1, updated_at = NOW() WHERE id = $2',
          [finalCost, shipmentId]
        );
      }

      await client.query('COMMIT');
      
      logger.info(`运单 ${shipmentId} 财务记录生成完成`, {
        finalCost,
        driverCommission: pricingCalculation?.totalDriverPay
      });

    } catch (error) {
      await client.query('ROLLBACK');
      logger.error(`运单 ${shipmentId} 财务记录生成失败`, error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * 生成应收记录
   */
  private async generateReceivableRecord(
    client: any, 
    shipment: any, 
    finalCost: number, 
    pricingCalculation?: any
  ): Promise<void> {
    
    // 2025-11-30T14:00:00Z Added by Assistant: 使用 tenant_id 确保租户隔离
    const tenantId = shipment.tenant_id;
    
    // 检查是否已存在应收记录（幂等性）
    const existingReceivable = await client.query(
      'SELECT id FROM financial_records WHERE tenant_id = $1 AND reference_id = $2 AND type = $3',
      [tenantId, (shipment.customer_id || shipment.id), 'receivable']
    );

    if (existingReceivable.rowCount > 0) {
      logger.info(`运单 ${shipment.id} 应收记录已存在，跳过生成`);
      return;
    }

    // 插入应收记录
    const receivableResult = await client.query(`
      INSERT INTO financial_records (tenant_id, type, reference_id, amount, currency, status, due_date, description, created_at)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
      RETURNING id
    `, [
      shipment.tenant_id,
      'receivable',
      shipment.customer_id || shipment.id,
      finalCost,
      'CAD', // TODO: 从运单获取币种
      'pending',
      new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30天后到期
      `运单 ${shipment.shipment_number} 的应收账款`
    ]);

    const receivableId = receivableResult.rows[0].id;

    // 插入应收费用明细组件
    if (pricingCalculation?.revenueBreakdown) {
      for (const component of pricingCalculation.revenueBreakdown) {
        await client.query(`
          INSERT INTO financial_records (tenant_id, type, reference_id, amount, currency, status, description, created_at)
          VALUES ($1, 'receivable_component', $2, $3, $4, 'pending', $5, NOW())
        `, [
          shipment.tenant_id,
          receivableId,
          component.amount,
          component.currency,
          `${component.componentName}: ${component.formula}`
        ]);
      }
    }

    logger.info(`运单 ${shipment.id} 应收记录已创建`, { receivableId, amount: finalCost });
  }

  /**
   * 生成应付记录（司机薪酬）
   */
  private async generatePayableRecord(
    client: any, 
    shipment: any, 
    finalCost: number, 
    pricingCalculation?: any
  ): Promise<void> {
    
    // 2025-11-30T14:00:00Z Added by Assistant: 使用 tenant_id 确保租户隔离
    const tenantId = shipment.tenant_id;
    
    // 检查是否已存在应付记录（幂等性）
    const existingPayable = await client.query(
      'SELECT id FROM financial_records WHERE tenant_id = $1 AND reference_id = $2 AND type = $3',
      [tenantId, (shipment.driver_id || shipment.id), 'payable']
    );

    if (existingPayable.rowCount > 0) {
      logger.info(`运单 ${shipment.id} 应付记录已存在，跳过生成`);
      return;
    }

    // 计算司机应付金额
    let driverAmount = 0;
    let driverDescription = '';

    if (pricingCalculation) {
      // 使用计费引擎计算的司机薪酬
      driverAmount = pricingCalculation.totalDriverPay;
      driverDescription = `运单 ${shipment.shipment_number} 的司机薪酬 - 计费引擎计算结果`;
    } else {
      // 使用简单的佣金比例（租户配置）
      const commissionRate = await this.getTenantCommissionRate(client, shipment.tenant_id);
      driverAmount = finalCost * commissionRate;
      driverDescription = `运单 ${shipment.shipment_number} 的司机薪酬 - 佣金比例 ${(commissionRate * 100).toFixed(1)}%`;
    }

    // 插入应付记录
    const payableResult = await client.query(`
      INSERT INTO financial_records (tenant_id, type, reference_id, amount, currency, status, due_date, description, created_at)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
      RETURNING id
    `, [
      shipment.tenant_id,
      'payable',
      shipment.driver_id || shipment.id,
      driverAmount,
      'CAD',
      'pending',
      new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7天后到期
      driverDescription
    ]);

    const payableId = payableResult.rows[0].id;

    // 插入司机薪酬明细组件
    if (pricingCalculation?.driverBreakdown) {
      for (const component of pricingCalculation.driverBreakdown) {
        await client.query(`
          INSERT INTO financial_records (tenant_id, type, reference_id, amount, currency, status, description, created_at)
          VALUES ($1, 'payable_component', $2, $3, $4, 'pending', $5, NOW())
        `, [
          shipment.tenant_id,
          payableId,
          component.amount,
          component.currency,
          `${component.componentName}: ${component.formula}`
        ]);
      }
    }

    logger.info(`运单 ${shipment.id} 应付记录已创建`, { payableId, amount: driverAmount });
  }

  /**
   * 获取租户的司机佣金比例
   */
  private async getTenantCommissionRate(client: any, tenantId: string): Promise<number> {
    try {
      const result = await client.query(
        'SELECT value FROM tenant_settings WHERE tenant_id = $1 AND key = $2',
        [tenantId, 'driverCommissionRate']
      );

      if (result.rowCount > 0) {
        const value = result.rows[0].value;
        return typeof value === 'number' ? value : parseFloat(value);
      }

      // 默认佣金比例 30%
      return 0.30;
      
    } catch (error) {
      logger.warn('获取佣金比例失败，使用默认值', { tenantId, error });
      return 0.30;
    }
  }

  /**
   * 构建运单上下文用于计费计算
   */
  private buildShipmentContext(shipment: any): any {
    return {
      shipmentId: shipment.id,
      tenantId: shipment.tenant_id,
      pickupLocation: {
        warehouseId: shipment.pickup_address?.warehouse_id,
        warehouseCode: shipment.pickup_address?.warehouse_code,
        address: shipment.pickup_address?.street || shipment.shipper_addr_line1,
        city: shipment.pickup_address?.city || shipment.shipper_city
      },
      deliveryLocation: {
        warehouseId: shipment.delivery_address?.warehouse_id,
        warehouseCode: shipment.delivery_address?.warehouse_code,
        address: shipment.delivery_address?.street || shipment.receiver_addr_line1,
        city: shipment.delivery_address?.city || shipment.receiver_city
      },
      distance: shipment.cargo_info?.distance || 25, // 默认25km
      weight: shipment.weight_kg || shipment.cargo_info?.weight || 0,
      volume: shipment.cargo_info?.volume,
      pallets: shipment.cargo_info?.pallets,
      actualWaitingTime: shipment.cargo_info?.waitingTime,
      customerId: shipment.customer_id,
      customerTier: shipment.customer_id ? 'STANDARD' : 'INTERNAL', // TODO: 从客户表获取
      driverId: shipment.driver_id,
      cargoType: shipment.cargo_info?.type || 'GENERAL_MERCHANDISE'
    };
  }

  /**
   * 批量生成财务报表（用于月末结算）
   */
  async generateMonthlyFinancialReport(tenantId: string, month: string): Promise<any> {
    const startDate = `${month}-01`;
    const endDate = `${month}-31`;

    try {
      const report = await this.db.query(`
        SELECT 
          COUNT(*) as total_shipments,
          SUM(CASE WHEN type = 'receivable' THEN amount ELSE 0 END) as total_receivable,
          SUM(CASE WHEN type = 'payable' THEN amount ELSE 0 END) as total_payable,
          SUM(CASE WHEN type = 'receivable' THEN amount ELSE 0 END) - SUM(CASE WHEN type = 'payable' THEN amount ELSE 0 END) as gross_profit
        FROM financial_records fr
        INNER JOIN shipments s ON fr.reference_id = s.id
        WHERE s.tenant_id = $1 
          AND DATE(fr.created_at) BETWEEN $2 AND $3
          AND fr.type IN ('receivable', 'payable')
      `, [tenantId, startDate, endDate]);

      return {
        period: { start: startDate, end: endDate },
        summary: report.rows[0],
        generatedAt: new Date().toISOString()
      };

    } catch (error) {
      logger.error('生成月度财务报表失败', { tenantId, month, error });
      throw error;
    }
  }

  /**
   * 检查运单状态变更是否需要更新财务记录
   */
  async checkFinancialRecordSync(shipmentId: string): Promise<{ synced: boolean; issues: string[] }> {
    const issues: string[] = [];

    try {
      // 获取运单和财务记录
      const shipmentResult = await this.db.query(
        'SELECT * FROM shipments WHERE id = $1',
        [shipmentId]
      );

      const financialResult = await this.db.query(
        'SELECT * FROM financial_records WHERE reference_id = $1',
        [shipmentId]
      );

      const shipment = shipmentResult.rows[0];
      const financialRecords = financialResult.rows;

      if (!shipment) {
        issues.push('运单不存在');
      }

      if (shipment.status === 'completed') {
        // 检查应收应付记录是否存在
        const receivable = financialRecords.find(r => r.type === 'receivable');
        const payable = financialRecords.find(r => r.type === 'payable');

        if (!receivable) {
          issues.push('缺少应收记录');
        }
        if (!payable) {
          issues.push('缺少应付记录');
        }

        // 检查金额一致性
        if (receivable && payable) {
          const totalPayable = financialRecords
            .filter(r => r.type === 'payable')
            .reduce((sum, r) => sum + parseFloat(r.amount), 0);

          const totalReceivable = financialRecords
            .filter(r => r.type === 'receivable')
            .reduce((sum, r) => sum + parseFloat(r.amount), 0);

          const receivableFromShipment = shipment.final_cost;
          
          if (totalReceivable !== receivableFromShipment) {
            issues.push(`应收总额 ${totalReceivable} 与运单费用 ${receivableFromShipment} 不一致`);
          }

          if (totalPayable > totalReceivable) {
            issues.push(`应付总额 ${totalPayable} 大于应收总额 ${totalReceivable}`);
          }
        }
      }

      return {
        synced: issues.length === 0,
        issues
      };

    } catch (error) {
      logger.error('检查财务记录同步状态失败', { shipmentId, error });
      return {
        synced: false,
        issues: ['检查过程中发生错误']
      };
    }
  }
}